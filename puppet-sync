#!/usr/bin/env ruby
#
# Copyright 2011, Reid Vandewiele <marut@cat.pdx.edu>
#
# Contains elements taken from:
#
#   Stefan Schlesinger:
#   https://github.com/sts/puppet-sync
#
#   Adrien Thebo:
#   http://puppetlabs.com/blog/git-workflow-and-puppet-environments
#
# Puppet-Sync
#
# This script may be used to sync a git branch from your repository
# to puppet master.
#
# Source code: http://www.github.com/pdxcat/puppet-sync
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

require 'fileutils'
require 'net/ssh'
require 'optparse'
require 'ostruct'

class Net::SSH::Connection::Session
  def do!(command)
    result = nil
    channel = self.open_channel do |ch|
      ch.exec(command) do |ch, success|
        raise "FAILED: unable to execute command #{command}" unless success
        channel.on_request('exit-status') do |ch, data|
          result = data.read_long
        end
      end
    end
    channel.wait
    result == 0 || nil
  end
end

class PuppetSync

  VERSION = "1.2-pdxcat1"
  STAMP   = ".puppet-sync-stamp"

  def initialize(arguments)
    @arguments = arguments
    @options   = OpenStruct.new

    # Default Options
    @options.delete       = false
    @options.deploy       = '/etc/puppet/environments'
    @options.passenger    = false
    @options.puppetmaster = 'localhost'
    @options.verbose      = false

    # Ensure nothing unexpected happens because of environment variables
    ENV.delete('GIT_DIR')
  end

  def run
    unless parsed_options? && arguments_valid?
      raise "ERROR: invalid arguments given."
    end

    case @options.puppetmaster
    when 'localhost', '127.0.0.1', '::1'
      target = 'local'
    else
      target = 'remote'
    end

    case @options.stdin
    when true
      source = 'stdin'
    else
      source = 'args'
    end

    self.send("run_#{target}_#{source}")
  end

  def run_local_args
    puts "Entering:  run_local_args" if @options.verbose
    run_local(:branch => @options.branch, :delete => @options.delete)
  end

  def run_local_stdin
    puts "Entering:  run_local_stdin" if @options.verbose
    STDIN.each_line do |line|
      oldrev, newrev, refname = line.split(" ")

      branch = refname.sub(%r{^refs/heads/(.*$)}) { $1 }
      if branch =~ /[\W-]/
        puts %Q{Branch "#{branch}" contains non-word characters, ignoring it.}
        next
      end

      delete = newrev.match(/^0+$/)
      run_local(:branch => branch, :delete => delete)
    end
  end

  def run_local(opts={})
    puts "Entering:  run_local" if @options.verbose
    deploy = deploy_directory(opts[:branch])

    if File.exists?(deploy) and not File.exists?("#{deploy}/#{STAMP}")
      raise "ERROR: Environment directory is not managed by puppet-sync."
    end

    if opts[:delete]
      FileUtils.remove_dir(deploy) if File.exists?(deploy)
      puts "Deleting: #{deploy}" if @options.verbose
    else
      unless File.directory?(deploy)
        execute git(:clone,  @options.repository, deploy, '-b', opts[:branch])
      end

      Dir.chdir(deploy) do
        execute git(:fetch, 'origin')
        execute git(:reset, '--hard')
        execute git(:checkout, "origin/#{opts[:branch]}")
        execute git(:submodule, 'update', '--init', '--recursive')
        execute git(:clean, '-d', '-x', '-f')
        FileUtils.touch(STAMP)
      end
    end
  end

  def run_remote_args
    puts "Entering:  run_remote_args" if @options.verbose
    run_remote([:branch => @options.branch, :delete => @options.delete])
  end

  def run_remote_stdin
    puts "Entering:  run_remote_stdin" if @options.verbose

    branches = Array.new

    STDIN.each_line do |line|
      oldrev, newrev, refname = line.split(" ")

      branch = refname.sub(%r{^refs/heads/(.*$)}) { $1 }
      if branch =~ /[\W-]/
        puts %Q{Branch "#{branch}" contains non-word characters, ignoring it.}
        next
      end

      branches << {:branch => branch, :delete => newrev.match(/^0+$/)}
    end

    run_remote(branches)
  end

  def run_remote(branches)
    puts "Entering:  run_remote" if @options.verbose

    if @options.password
      args = { :password => @options.password, :auth_methods => 'password' }
    else
      args = { :keys => @options.identity, :auth_methods => 'publickey' }
    end

    begin
      session = Net::SSH.start(@options.puppetmaster, @options.login, args)
    rescue Net::SSH::AuthenticationFailed
      abort "Abort: Authentication failed while connecting to #{@options.puppetmaster}"
    rescue OpenSSL::PKey::PKeyError
      abort "Abort: #{@options.identity}: cannot open or is not a valid private key file"
    rescue => exception
      abort "Abort: #{exception.message}"
    end

    branches.each do |opts|
      branch = opts[:branch]
      delete = opts[:delete]
      deploy = deploy_directory(opts[:branch])

      if session.do!("test -e #{deploy}") and not session.do!("test -e #{deploy}/#{STAMP}")
        raise "ERROR: Environment directory is not managed by puppet-sync."
      end

      if delete
        session.do!("/bin/rm -rf '#{deploy}'") if session.do!("test -d '#{deploy}'")
        puts "Deleting: #{@options.puppetmaster}:#{deploy}" if @options.verbose
      else
        unless session.do!("test -d '#{deploy}'")
          result = ssh_execute(session, git(:clone,  @options.repository, deploy, '-b', branch))
          if result.match(/using HEAD instead$/)
            session.do!("/bin/rm -rf '#{deploy}'") if session.do!("test -d '#{deploy}'")
            abort "Abort: #{@options.puppetmaster}@#{@options.login}: #{result[:output]}"
          end
        end

        ssh_execute(session, "cd #{deploy} && #{git(:fetch, 'origin')}")
        ssh_execute(session, "cd #{deploy} && #{git(:reset, '--hard')}")
        ssh_execute(session, "cd #{deploy} && #{git(:checkout, "origin/#{opts[:branch]}")}")
        ssh_execute(session, "cd #{deploy} && #{git(:submodule, 'update', '--init', '--recursive')}")
        ssh_execute(session, "cd #{deploy} && #{git(:clean, '-d', '-x', '-f')}")
        ssh_execute(session, "cd #{deploy} && touch #{STAMP}")
      end

    end
  end

  def git(command, *args)
    @gitverbose ||= @options.verbose ? '' : '--quiet'
    case command.to_sym
    when :config
      command = ["git #{command.to_s}", args].flatten.compact.join(' ')
    else
      command = ["git #{command.to_s} #{@gitverbose}", args].flatten.compact.join(' ')
    end
  end

  def execute(command)
    puts "Executing: #{command}" if @options.verbose
    result = IO.popen(command).readlines
    puts result if @options.verbose
  end

  def ssh_execute(session, command)
    result = Hash.new
    channel = session.open_channel do |ch|
      puts "#{@options.login}@#{@options.puppetmaster}: #{command}" if @options.verbose
      ch.exec(command) do |ch, success|
        raise "FAILED: unable to execute command #{command}" unless success
        channel.on_data do |ch, data|
          puts data.to_s if @options.verbose
        end
        channel.on_extended_data do |ch, type, data|
          puts data.to_s
        end
        channel.on_request('exit-status') do |ch, data|
          result[:exit_code] = data.read_long
        end
        channel.on_request('exit-signal') do |ch, data|
          result[:exit_signal] = data.read_long
        end
      end
    end
    channel.wait
    return result
  end

  def deploy_directory(branch)
    if branch == "master"
      return "#{@options.deploy}/production"
    else
      return "#{@options.deploy}/#{branch}"
    end
  end

  def parsed_options?
    opts = OptionParser.new

    opts.banner = "Usage: puppet-sync -b BRANCH [options]"

    opts.on('-b', '--branch BRANCH', 'Mandatory, specify the git branch to clone.') do |branch|
      @options.branch = branch
      raise "ERROR: --branch and --stdin are incompatible arguments." if @options.stdin
    end

    opts.on('-s', '--stdin', 'Retrieve branch and revision information from stdin.') do
      @options.stdin = true
      raise "ERROR: --branch and --stdin are incompatible arguments." if @options.branch
    end

    opts.on('-p', '--puppetmaster HOST', 'Specify the host to deploy to.') do |host|
      @options.puppetmaster = host
    end

    opts.on('-d', '--deploy DIR', 'Specify the directory to deploy to.') do |deploy|
      @options.deploy = deploy
    end

    opts.on('-D', '--delete', 'Remove the specified branch from the deployment directory.') do
      @options.delete = true
    end

    opts.on('-r', '--repository URL', 'Git url for the repository.') do |repo|
      @options.repository = repo
    end

    opts.on('-i', '--identity FILE', 'Identity file (key) for connecting to the puppetmaster.') do |identity|
      @options.identity = identity
      raise "ERROR: --identity and --password are incompatible arguments." if @options.password
    end

    opts.on('-W', '--password PASS', 'Password for connecting to the puppetmaster.') do |password|
      @options.password = password
      raise "ERROR: --identity and --password are incompatible arguments." if @options.identity
    end

    opts.on('-l', '--login USER', 'Git url for the repository.') do |login|
      @options.login = login
    end

    opts.separator "Common options:"
    opts.on('-V', '--version', 'Display the script version.') { output_version ; exit 0; }
    opts.on('-v', '--verbose', 'Be more verbose.') { @options.verbose = true }
    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end

    opts.parse!(@arguments) rescue return false
    true
  end

  def arguments_valid?
    case
    when @options.repository.nil?
      valid = false
    when  @options.branch.nil? && @options.stdin.nil?
      valid = false
    when @options.puppetmaster.match(/localhost|127.0.0.1|::1/).nil? && @options.password.nil? && @options.identity.nil?
      valid = false
    else
      valid = true
    end
    return valid
  end

  def output_version
    puts VERSION
  end

end

app = PuppetSync.new(ARGV)
app.run
